// ---------- Generators & Datasource ----------
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ---------- Enums ----------
enum Language {
  FR
  EN
  DE
}

enum VocabStatus {
  unknown
  green
  red
}

enum VocabReferenceKind {
  DEFAULT   // points to external JSON list `default_vocab` via reference_id
  CUSTOM    // points to CustomVocab via custom_vocab_id
}

// ---------- Models ----------
model User {
  id             Int       @id @default(autoincrement())
  uid            String    @unique       // Firebase UID
  email          String?
  emailVerified  Boolean   @default(false)
  createdAt      DateTime  @default(now())

  source_lang    Language  @default(EN)
  target_lang    Language  @default(FR)
  has_generated_default_lists Boolean @default(false)
  communicate_important_updates Boolean @default(true)

  // One-to-one favourite list pointer (unique makes it 1:1)
  favourite_list Int?      @unique
  favouriteList  VocabList?  @relation("FavouriteListRelation", fields: [favourite_list], references: [list_id])

  // All lists owned by the user (1:N)
  lists          VocabList[] @relation("OwnedListsRelation")

  customVocabs   CustomVocab[]
  hidden         HiddenVocab[]
  topicProgress  TopicProgress[]
  mockExams      MockExam[]
}

model CustomVocab {
  custom_vocab_id Int       @id @default(autoincrement())
  userId          Int      // Converted to required Int
  target_lang     Language
  source_lang     Language
  source_text     String
  target_text     String

  user  User   @relation(fields: [userId], references: [id])
  vocab Vocab[]

  @@index([userId])
}

model Vocab {
  vocab_id        Int                 @id @default(autoincrement())
  reference_id    Int?                // If DEFAULT: id (0..9999) from external JSON
  reference_kind  VocabReferenceKind
  custom_vocab_id Int?                // If CUSTOM: FK to CustomVocab
  
  customVocab CustomVocab?  @relation(fields: [custom_vocab_id], references: [custom_vocab_id])
  listItems   VocabListItem[]
  hiddenBy    HiddenVocab[]

  @@index([reference_kind, reference_id])
  @@index([custom_vocab_id])
}

model HiddenVocab {
  userId   Int      // Converted to required Int
  vocab_id Int

  user  User  @relation(fields: [userId], references: [id])
  vocab Vocab @relation(fields: [vocab_id], references: [vocab_id])

  @@id([userId, vocab_id])
}

model VocabList {
  list_id   Int      @id @default(autoincrement())
  userId    Int      // Converted to required Int
  list_name String

  // Owner side of 1:N (must share relation name with User.lists)
  user  User @relation("OwnedListsRelation", fields: [userId], references: [id])

  // Backfield for the 1:1 favourite list relation (singular)
  favouritedByUser User? @relation("FavouriteListRelation")

  items VocabListItem[]

  // A user cannot have two lists with the same name
  @@unique([userId, list_name])
  @@index([userId])
}

model VocabListItem {
  id           Int          @id @default(autoincrement())
  list_id      Int
  vocab_id     Int

  // Progress fields
  list_name    String?
  importance   Float        @default(0)
  timesGreen   Int          @default(0)
  timesRed     Int          @default(0)
  vocab_status VocabStatus  @default(unknown)

  listRef VocabList @relation(fields: [list_id], references: [list_id])
  vocab   Vocab     @relation(fields: [vocab_id], references: [vocab_id])

  @@unique([list_id, vocab_id])
  @@index([vocab_id])
}

// ---------- Progress Tracking ----------

enum TopicSection {
  DIALOGUE    // 0
  DISCUSSION  // 1
}

model TopicProgress {
  id        Int          @id @default(autoincrement())
  user_id   Int
  section   TopicSection
  topic_id  Int          // The ID of the scenario/discussion item

  user      User         @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@unique([user_id, section, topic_id])
  @@index([user_id])
  @@map("topic_progress")
}

// ---------- Mock Exam System ----------

enum SectionType {
  A1
  A2
  B1
}

// Scenarios (JSON id storage)
model ScenarioA1 {
  id          String @id // This will match the ID in the JSON file (e.g., "paper1_a1_spoken")
  title       String
  contentJson String @db.Text // Storing the full JSON content or path if needed
  
  mockExams   MockExam[] @relation("A1Scenario")
}

model ScenarioA2 {
  id          String @id
  title       String
  contentJson String @db.Text
  
  mockExams   MockExam[] @relation("A2Scenario")
}

model ScenarioB1 {
  id          String @id
  title       String
  contentJson String @db.Text
  
  mockExamsSelected MockExam[] @relation("B1Selected")
  mockExamsOption1  MockExam[] @relation("B1Option1")
  mockExamsOption2  MockExam[] @relation("B1Option2")
}

enum ExamPath {
  A1
  B1
}

// The Mock Exam Session
model MockExam {
  id          String @id @default(uuid())
  user_id     Int
  user        User   @relation(fields: [user_id], references: [id])
  
  // Explicitly track which path the user took
  selected_path ExamPath?

  // Direct links to scenarios
  scenario_a2_id String
  scenario_a2    ScenarioA2 @relation("A2Scenario", fields: [scenario_a2_id], references: [id])
  
  scenario_a1_id String?
  scenario_a1    ScenarioA1? @relation("A1Scenario", fields: [scenario_a1_id], references: [id])
  
  // B1 Options: Pre-created when exam starts
  scenario_b1_option1_id String?
  scenario_b1_option1    ScenarioB1? @relation("B1Option1", fields: [scenario_b1_option1_id], references: [id])
  
  scenario_b1_option2_id String?
  scenario_b1_option2    ScenarioB1? @relation("B1Option2", fields: [scenario_b1_option2_id], references: [id])
  
  // B1 Selected: Points to which B1 option was chosen
  scenario_b1_id String?
  scenario_b1    ScenarioB1? @relation("B1Selected", fields: [scenario_b1_id], references: [id])

  answersA1     MockExamAnswerA1[]
  answersA2     MockExamAnswerA2[]
  answersB1     MockExamAnswerB1[]

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  status      String   @default("IN_PROGRESS") // IN_PROGRESS, COMPLETED
}

// Section-Specific Answers
model MockExamAnswerA1 {
  id            String      @id @default(uuid())
  mock_exam_id  String
  mockExam      MockExam    @relation(fields: [mock_exam_id], references: [id])
  
  user_id       Int
  question_id   String
  answer_text   String?     @db.Text
  audio_url     String?     
  
  createdAt     DateTime    @default(now())

  @@unique([user_id, mock_exam_id, question_id])
}

model MockExamAnswerA2 {
  id            String      @id @default(uuid())
  mock_exam_id  String
  mockExam      MockExam    @relation(fields: [mock_exam_id], references: [id])
  
  user_id       Int
  question_id   String
  answer_text   String?     @db.Text
  audio_url     String?     
  
  createdAt     DateTime    @default(now())

  @@unique([user_id, mock_exam_id, question_id])
}

model MockExamAnswerB1 {
  id            String      @id @default(uuid())
  mock_exam_id  String
  mockExam      MockExam    @relation(fields: [mock_exam_id], references: [id])
  
  user_id       Int
  question_id   String
  answer_text   String?     @db.Text
  audio_url     String?     
  
  createdAt     DateTime    @default(now())

  @@unique([user_id, mock_exam_id, question_id])
}